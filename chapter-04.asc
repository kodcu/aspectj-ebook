== Pointcut Yapısı

_Pointcut_ üniteleri birleşim noktalarından oluşurlar. Pointcut, belirlenen birleşim noktalarını seçerek bir bütün oluşturduğundan dolayı dilimizde _"birleşim nokta kümesi"_ olarak söylenebilir. Pointcut, aspect kaynak dosyalarının (.aj uzantılı dosyalar) içinde yaratılan sınıfların, arayüzlerin ve ilgi birimlerinin içinde tanımlamak mümkündür. Pointcut yapılarını 2 farklı yol ile oluşturabiliriz:

1. _Isimlendirilen_ (named)
2. _Anonim_ (anonymous) 

### Named Pointcut 

İsimlendirilerek kullanılan bu pointcut tanımlaması birden çok yerde (ör. tavsiye yapısı tanımında, başka isimlendirilen pointcut tanımlamalarının içinde) tekrar tekrar kullanabiliriz. 

.Bir isimlendirilen pointcut tanımlamasına örnek
[source,aspectj]
----
public aspect AspectModule {

   private pointcut doPointcut() :                           <1> <2> <3>
                execution(public String Address.getCity());  <4>

}
----
<1> `private` erişim belirleyicisi  

<2> `pointcut` anahtar kelimesi

<3> Pointcut tanımlamasına verilen isim ve parametre bölümü `( )` 

<4> `: execution(...);` pointcut tanımlaması olarak belirlenen bölge. `execution(imza deseni)` yürütme pointcut (execution pointcut) yapısını göstermekte. 

IMPORTANT: Named pointcut tanımlamaları birden fazla pointcut yapılarından oluşabilir. Yukarıdaki örnekte temel pointcut lardan sadece biri olan `execution()` pointcut ile yaratılmıştır.  

`Address` sınıfına ait olan bu `getCity` metodunun eşlendiği noktayı aşağıda daha açık bir şekilde görmekteyiz: 

<<<

[source,java]
----
package information; 
public class Address {
    ...
>>> public String getCity(){     // + (execution(public String Address.getCity()))
                                 
        return this.city ;       
                                
    }                            
    ...
}                                                           
----
IMPORTANT: Bu pointcut tanımlamasına isim belirlerken birleşim noktalarında çalıştırılacak ilgilere göre bağlantılı bir isim verilmesi daha doğru bir yaklaşım olur.  

.Soyut Pointcut Tanımlaması
**** 
Named pointcut tanımlamaları aynı zamanda soyut olarak da pointcut üniteleri olmadan da tanımlanırlar. Bu named pointcut lar somut (concrete) aspect birimlerinin içinde temel pointcut yapılarının oluşturulması ile aktif hale gelirler. Kısaca çok biçimlilik (polymorphic) yaklaşımını bu bileşende de kullanmış oluruz. Soyut (abstract) pointcut lar sadece ama sadece soyut aspect birimlerinde tanımlanırlar ve yaratılırken erişim belirliyicilerden `public`, `protected` veya paket korumalı hali (`default` durum) olarak baştan belirlenmelidir.

[source,aspectj]
----
public abstract aspect AbstractAspect {

  public abstract pointcut doPointcut(); <1>
    
}

public aspect ConcreteAspect extends AbstractAspect {

  public pointcut doPointcut():execution(public String Address.getCity()); <2>
    
}
----
<1> Soyut named pointcut tanımı

<2> Aynı yapının somut olarak tanımı
****

.Örnek Soru 1:
[source,aspectj]
----
public aspect AbstractAspect {

  public abstract pointcut doPointcut();
    
}

public aspect ConcreteAspect extends AbstractAspect {

  protected pointcut doPointcut():execution(public String Address.getCity());
    
}
----
Yukarıdaki kod parçacığına göre sizce hangi şık(lar) doğrudur?::
    - [ ] a) Doğru olarak derlenir
    - [ ] b) Doğru derlenmesi için soyut pointcut'ın `public` belirleyicisi `protected` olmalı
    - [ ] c) Doğru derlenmesi için somut pointcut'ın `protected` belirleyicisi `public` olmalı
    - [ ] d) Doğru derlenmesi için 2 pointcut tanımının `private` olması gerekir 
    - [ ] e) Hiçbiri değil
    

### Anonymous Pointcut 

Anonim pointcut tanımlamaları sistemde sadece bir kez kullanılacak ilgiler için tercih edilmektedir. Birden çok yerde aynı pointcut tanımlamalarını anonim şekilde kullanmak kopyala-yapıştır mantığını fazlasıyla kullanmanıza yol açıcak ve `tavsiye` birimleri ile birlikte `aspect` yapısının anlaşılmasını zorlaştıracaktır. 

NOTE: "_Pointcut tanımlamaları_" tüm pointcut yapılarını kapsamaktadır.

Önceden gösterilen aynı pointcut tanımlamasını bu sefer anonim olarak uygulamamız için mevcut tavsiye yapılarıyla direk bağlamamız gerekmektedir. İki nokta `:` ile başlayıp süslü parantez `{` ile sonlanan mesafe bizim anonim pointcut yapımızı temsil etmektedir. 

<<<

.Bir anonim pointcut tanımlaması
[source,aspectj]
----
public aspect AspectModule {

    // after advice                                          
    after() : execution(public String Address.getCity()) {  
        // advice body
    }
    
}
----

Aynı zamanda anonim pointcut tanımlamaları, named pointcut lar ile birleşip tavsiye yapılarının oluşturulmasında kullanılabilir.

[source,aspectj]
----
public aspect AspectModule {

 public pointcut doPointcut() : execution(* getCity());
 
 // after advice                                          
 after() : doPointcut() && within(information.Address) {  
     // advice body
 }
    
}
----

### Pointcut Operatörleri

Karmaşık koşulları düzenlemede kullandığımız Java'nın bize sunduğu unary (tekli) ve binary (çifli) operatörlerinin bazılarını AspectJ dilinde de kullanabiliyoruz. 

* *Unary Operatörü*: AspectJ dili tek bir unary operatöründen faydalanmaktadır: tersi/olumsuzluk koşulu (`!`). Seçmek istemediğimiz birleşim noktalarında bu öperatörü kullanarak istediğimiz sonuca ulaşabiliriz. Örneğin; `!within(information.Library)` pointcut yapısı ile `information` paketinin içinde bulunan `Library` sınıfında meydana gelen tüm birleşim noktalarını hariç tutabiliyoruz.

* *Binary Operatörleri*: AspectJ aynı zamanda 2 binary operatöründen faydalanmaktadır: `&&` (koşullu ve) ve `||` (koşullu veya). Bildiği gibi bu operatörler Java geliştiricileri tarafından belli senaryolara göre en çok kullanılan koşullardır. Bu 2 operatör sayesinde biz de pointcut'ları (named ve diğer pointcut lar dahil) birleştirebiliyoruz. 

<<<

*Örneğin;*

[source,aspectj]
----
public aspect AspectModule {

 public pointcut doPointcut() : execution(* doSomething());
 
 // after advice                                          
 after() : doPointcut() && !within(information.Library) {  <1>
     // advice body
 }
    
}
----
<1> `information` paketinin içindeki `Library` sınıfında, erişim belirleyicilerine (`public`, `protected`, `private` ve `default`) ve metodun dönüş tipine bakılmaksızın, hiç parametresi olmayan `doSomething` metodlarını *hariç* tutup, projedeki diğer paketlerin içindeki *her bir* `doSomething` metodunun (aynı şekilde erişim belirleyicilerini ve metodun dönüş tipini hariç tutup aynı zamanda parametre bulundurmayanlar) yürütme noktalarını (method-execution join point) eşler.

### İmza Desenleri

İmza desenleri bir temel pointcut tanımının oluşturulabilmesi için çok önemlidir. İmza desenlerini kullanarak <<Join Point Yapısı>> kısmında belirtilen birleşim noktalarını eşleme imkanına sahip olacaz. Ayrıca, bu desenlerin içerisinde kullanabileceğimiz, AspectJ'nin bize sunduğu, bazı özel semboller (wildcards) mevcut. Bu özel sembolleri kullanarak daha kolay bir şekilde birden fazla birleşim noktasına erişme imkanına sahip olacaz. Diğer bir deyişle, yazılan tek bir imza formatı ile tek bir tavsiye yapısını, birden fazla birleşim noktasını seçmek için kullanabilicez. 

Bu semboller sırasıyla: artı (`+`), 2 nokta (`..`) ve yıldız (`*`, asterisk) dır.

#### Artı Sembolü

Artı  (`+`) sembolü, mevcut olan bir birimin (sınıf, alt sınıf (subclass), arayüz, ilgi (aspect), alt ilgi (subaspect) vb) her bir alt/türemiş birimini belirtir.

<<<

[source,aspectj]
----
public aspect AspectModule {

 public pointcut doPointcut() : execution(* doSomething());
 
 // after advice                                          
 after() : doPointcut() && 
           within(information.Address+) {  <1>
     // advice body
 }
 
}
----

<1> `within(information.Address+)` pointcut ile hem `Address` sınıfını hem de onun her bir alt sınıfını (subclasses) kapsar. Genel olarak tavsiye yapısı, erişim belirleyicilerini ve metodun dönüş tipine bakılmaksızın tüm `doSomething` metodlarını `Address` ve onun alt sınıflarında arayıp eşler. Ek olarak, artı sembolü, mevcut birim isimlerinin sonuna eklenerek kullanılır.

Eğer `within` pointcut yapısının içinde tüm paket yolunu yazmak istemeyip sadece birimin ismini göstermek isterseniz, gösterilecek birimin paket yolunu `import` işlemiyle eklemek gerekmektedir -- bu işlemi diğer pointcut yapılarında da geçerlidir --:

[source,aspectj]
----
import information.Address;

public aspect AspectModule {

 public pointcut doPointcut() : execution(* doSomething());
 
 // after advice                                          
 after() : doPointcut() && 
           within(Address+) {  
     // advice body
 }
    
}
----

<<<

.Örnek Soru 2:
[source,java]
----
package com.book;
public class Library { }

package com.book.store;
public class BookStore extends Library { }

package com.book.staff;
class Librarian extends Library{}

package com.book.staff;
interface Controllable {}

package com.book.store.business;
class BookStoreBusiness extends BookStore { }
----
Hangi birimler `within(com.book.store+.BookStore)` ile etkilenir?::
    - [ ] a) `Library`
    - [ ] b) `BookStore`
    - [ ] c) `Controllable`
    - [ ] d) `BookStoreBusiness` 
    - [ ] e) Derleme hatası

''''

#### İki Nokta Sembolü 

İki nokta sembolü (`..`) 2 farklı imza deseni için farklı fonksiyonlara sahiptir.

* *Metodların* (Method Signature) parametrelerinin gelişigüzel değer vermek için kullanılır. Eğer sembol, bir metodun hiç bir parametresi olmadığı halde de kullanılırsa, her hangi bir derleme hatası oluşmaz.

.Örnek 1: 3 metoda sahip `Library` sınıfı
[source,java]
----
package com.book;
public class Library { 
    public void doSomething(){}
    public void doSomethingMore(Object param1,byte param2){}
    private String doSomethingPlus(String param1,int param2,int param3){}
}
----

.Örnek 2
[source,aspectj]
----
public aspect AspectModule{
	
	pointcut doPointcut(): execution(private String doSomethingPlus(..)); <1>
	
}
----
<1> Named pointcut içerisinde tanımlanan `execution` pointcut, sistemdeki erişim belirleyicisi `public`, dönüş tipi `String` sınıfı olan, 0 ve 0'dan fazla parametreye sahip her bir `doSomethingPlus` metodunu tarayıp bulur ve eşlenir. 

.Örnek 3
[source,aspectj]
----
public aspect AspectModule{
	
 pointcut doPointcut(): 
     execution(private String com.book.Library.doSomethingPlus(..)); <1>
	
}
----
<1> Named pointcut içerisinde, `method-execution` noktasını seçmek için kullanılan `execution` pointcut, sistemdeki erişim belirleyicisi `public`, dönüş tipi `String` sınıfı olan, 0 ve 0'dan fazla parametreye sahip sadece `Library` sınıfının sahip olduğu her bir `doSomethingPlus` metodunu tarayıp bulur ve eşlenir. 

''''
* *Tipler* (Type Signature) için anlamı, dolaylı ve dolaysız tüm alt paketleri dahil etmektir.

.Örnek 4
[source,aspectj]
----
package com.book;
public class Library { void doSomething(){} }

package com.book.store;
public class BookStore { void doSomething(<3 params>) }

package com.staff.book;
class Librarian extends Library{ void doSomething(){} }

package com.staff.book;
interface Controllable {}

package com.book.transition.business;
class BookStoreBusiness { void doSomething(){} }

public aspect AspectModule{
 public pointcut doPointcut() : execution(* doSomething(..));
 
 // after advice                                          
 after() : doPointcut() && 
           within(com.book..*) {  <1>
     // advice body
 }
}
----
<1> `com.book`, `com.book.store` ve `com.book.transition.business` paketlerinin içerisindeki birimleri seç ve gene her birime bakarak `doSomething` ismindeki metodlara bağlan.

#### Yıldız Sembolü 

Bu sembol genel anlamda her bir karakter sayısını belirtmektedir. Tip imza desenlerinde (Type Signature), paket ve tüm tiplerin isimlerinin belli kısımlarını tamamlamada kullanılır. Diğer imza desenlerinde (_Metod_ (Method Signature) ve _Alan_ (Field Signature) desenleri gibi) isimlerin belli kısımlarını belirtirler.

.Örnek 5: Tüm sembollerin kullanımı
[source,aspectj]
----
package com.book;
public class Library { 

>>>    public void doSomething(){}
    
>>>    public void doSomethingMore(Object param1,byte param2){}
    
>>>    private String doSomethingPlus(String param1,int param2,int param3){}
}

package com.book.transition.business;
class BookStoreBusiness extends Library { 
>>>   void doSomething(){} 
}

package com.staff.book;
class Librarian extends Library { 
     void doSomething(){} 
}



public aspect AspectModule{
	
    pointcut doPointcut(): 
        execution(* com.book.Library+.doSomething*(..)) && <1>
        within(com.book..*);                               <2>
	
    before() :doPointcut(){                                <3>
        // before advice body
    }
}
----
<1> `Library` ve ondan türeyen alt sınıfların birimlerini dikkate alarak, erişim belirleyicisine, dönüş tipine ve parametre sayısına bakılmaksızın, `doSomething` ile başlayan her bir metodu seç. Bu sonuç ile `Librarian` sınıfındaki metod da seçiliyor.

<2> `com.book` ve `com.book.transition.business` paketlerinin içerisindeki birimleri dikkate al. Bu sonuç ile `Librarian` sınıfındaki metod eleniyor.

<3> Ortak bir sonuca ulasmak için uygulanan `&&` (ve koşulu) bize, `Library` ve `BookStoreBusiness` sınıfındaki metodları döndürüyor. `>>>` ile işaretli olan birleşim nokta gölgelerini kod parçasında görmekteyiz.

'''
Sembolleri açıklarken bazı temel pointcut yapılarını ve onların içerisinde barınan imza desenlerini biraz olsun görmüş olduk. Toplam 4 tane temel imza deseni vardır. Bu imza desenleri, Java elementlerini belli bir formatta yazmamıza olanak sağlıyor. Ayrıca, bu imzaları bağlantılı pointcut yapılarında kullanarak toplam da 10 tane birleşim noktasını (`advice execution` noktası imza istememektedir) seçme imkanımna sahip oluyoruz.

Bu imza desenleri::

* *Type Signature* (Tip İmza Deseni)
* *Method Signature*  (Metod İmza Deseni)
* *Constructor Signature* (Yapıcı İmza Deseni)
* *Field Signature* (Alan İmza Deseni)
* *Throw Signature* (Fırlatma İmza Deseni)

#### Type Signature Pattern 

Type, genel anlamda Java elemenlerinde sınıfları (classes), arayüzlerin (interfaces), notasyonları (annotations) ve veri tiplerini (data types) belirtir. AspectJ elementlerinden de ilgileri (aspects) belirtir.

.Bazı tip imza örnekleri
[width="100%",options="header",cols="3,4,5"]
|====================
|İmza Deseni | Açıklama  | Örnek  
|Library  | `Library` sınıf tipi |  Sadece `Library` sınıfı
|com.staff.book | `com.staff.book` paketi içindeki tüm tipler  | `com.staff.book.Librarian`
|com.****.business..**** | Başlangış paketi `com` ve 3. paket ismi `business` olan paketlerin içerisindeki her tipi seç| `com.book.business` ve `com.account.business`
|*Terminal | Sonu `Terminal` ile biten tüm tipleri seç | `UtilityTerminal` ve `BuildingTerminal` 
| business.Cus*y | `business` paketinin içindeki `Cus` ile başlayıp `y` ile biten tüm tipler | `business.CustomUtility` ve `business.CustomerSummary`
|====================

#### Method Signature Pattern

Metod imza deseni, `call()` ve `execution()` pointcut yapılarında kullanılır. Bu imza desenlerinde erişim belirleyiciler isteğe bağlı olarak kullanılır. Ayrıca bu erişim belirleyicilerde olumsuzluk koşulu (`!`) kullanılabilir. Bir metod yapısı isteğe bağlı olarak @Annotation ve erişim belirleyici (ör. `private`) ile başlar, dönüş tipi, metod ismi ve parametre yapısı ile noktalanır. Ayrıca belirli metodları seçmek için metodun yaratıldığı tip de belirtilebilir imzanın içerisinde (ör: `Account.getID()`). 

.Bazı metod imza örnekleri
[width="100%",options="header",cols="4,4,5"]
|====================
|İmza Deseni | Açıklama  | Örnek 
|public void Library.doSomething(*)  | `public` erişime sahip, dönüş tipi olmayan, 1 tane parametresi olan ve `Library` sınıfının içindeki her bir `doSomething` metodunu temsil eder. | `public class Library {
    public void doSomething(String param1){}
}`
| * doSomething(..) | Belirleyiciye, dönüş tipine, metod parametresine ve yaratıldığı birime bakılmaksızın her bir `doSomething` methodunu gösterir. | Bir önceki metod ve `private String Helper.doSomething(Object param1){}`
| public * Library.doSomething (Object) | Dönüş tipine bakılmaksızın, belirleyicisi `public` olan , 1 tane metod parametresine sahip `Library` sınıfına bağlı olan `doSomething` methodunu gösterir. |  `public class Library { public String doSomething(Object param1){} public void doSomething(Object param1){}}`
| * ***.* (..) ya da * *(..) | Belirleyiciye, dönüş tipine, tanımlandığı tipe, parametre sayısına ve metod ismine bakılmaksızın sistemdeki tüm metodları gösterir. | Projedeki tüm metod tanımlamaları
| !static * Library.*(..) | Belirleyicisi statik olmayan, dönüş tipi, metod ismi ve parametre sayısınına bakılmaksızın `Library` sınıfında tanımlanmış her bir metodu belirtir. |  `public class Library { private void countSomething(){} public Object makeSomething(){}}`
| * Library.doSomething(..) throws Exception| Belirleyiciye, dönüş tipine ve parametre sayısına bakılmaksızın `Library` sınıfında yaratılan ve `Exception` yapısında istisna fırlatan `doSomething` metodlarını gösterir.  | `class Library { public void doSomething() throws Exception }}`
| * test.Test.main(..) | `Test` sınıfındaki `main` metodunu seçer | `class Test { public static void main(String... args) {}}` 
|====================

#### Constructor Signature Pattern

Metod imzası gibi _Yapıcı imza_, `call()` ve `execution()` pointcut yapılarını oluşumunda kullanılır. Bu imza desenlerinde erişim belirleyicileri isteğe bağlı olarak gösterilir. Java programlama dilinde eğer bir sınıfın içinde tanımlanmış yapıcılar *yoksa*, o sınıf, çalışma zamanı (run-time) içinde *varsayılan* bir yapıcı metoda sahip olur ve bunu biz göremeyiz. Ayrıca, Java dilinde bir sınıfın içinde yapıcı(lar) tanımlanmışsa, *varsayılan* olarak tanımlanan (run-time içinde) yapıcı silinir, mevcut olan yapıcı tanımlamaları dikkate alınır.  Java'nın yapıcılar için koyduğu bu özellikler, AspectJ ile yapıcı noktalarının seçiminde de etkilidir. Eğer erişim belirleyicisi imza içerisinde kullanılacak ise, mevcut noktadaki yapıcının erişim belirleyicisiyle aynı olmak zorundadır. Yapıcı metodlarda isim bulunmadığı için ismin yerine `new` anahtar kelimesi gelir. Statik belirleyiciyi yapıcı metodlar için kullanamayız. Bir sınıfın tanımlanmış bir yapıcı metodu bulunmuyorsa, o sınıfın varsayılan yapıcı metoduna direkt bağlanılır.

.Örnekler
[source,aspectj]
----
package com.book;
public class Library { 
    public List<String> books = new ArrayList<String>();
}

package com.book.store;
public class BookStore extends Library { 
    public BookStore(){}
    public BookStore(String param1){}
}

package com.staff;
class Librarian extends Library{
    protected Librarian(){}
    public Librarian(String param1){}

    void doSomething(){
        Library library = new Library();
    }

    void doSomething(String param1){
        String string = "do nothing";
        System.out.println("Next :" + string); 
    }
}



package com.staff;
interface Movable {}
package com.book.store.business;
class BookStoreBusiness extends BookStore {
    final DateTime date = new DateTime();
    BookStoreBusiness(){}
}

package com.book;
public aspect AspectModule {
    
    pointcut doPointcut(): execution(com.book.*.new(..));       <1>

    pointcut doPointcut2(): execution(com.book..*.new(..));     <2>

    pointcut doPointcut3(): call(com.book.Library.new(..));     <3>

    pointcut doPointcut4(): call(*.new(..));                    <4>
}
----
<1> `com.book` paketinin içindeki birimlere ait her bir yapıcıyı seçer: `Library` ve `AspectModule`. Aspect birimlerin de sınıflar gibi *varsayılan* yapıcıları vardır, eğer aspect birimleri içinde yaratılmış yapıcı(lar) olmazsa.

<2> `com.book`, `com.book.store` ve `com.book.store.business` paketlerinin içerisindeki birimlerin yapıcılarını kapsamaktadır. `Library`, `AspectModule`, `BookStoreBusiness` ve `BookStore` sınıflarının yapıcılarını (varsayılan ve tanımlananlar) seçer.

<3> Sistemde `Library` sınıfının nesnesinin çağırıldığı noktaları seçer. `Librarian` sınıfının `doSomething` metodunun içinde yaratılan `Library` sınıfından nesne bu pointcut tarafından seçilir.

<4> Sistemde yaratılan her bir nesne çağırmalarını (constructor-call) seçmektedir. `books`, `library`, `"Next :"+ string` ve `date`, `new` ile yaratılan nesneler seçilir. `println` metodu içinde yazılan `("Next :"+ string)`, `println(new String("Next :"+ string))` olarak derlenmektedir. O yüzden bu satırı da bir birleşim noktası olarak belirleyebiliyoruz. Ekstra olarak, `throw new Exception("Sorry, you are late!");` istisna fırlatma noktası da bir `constructor-call` noktasıdır.

<<<

#### Field Signature Pattern

Alan imza deseni, sistemde yaratılan alanların okuma ve yazma amacıyla kullanıldıkları noktaları yakalamaktadır. Alan imzaları, `get()` -okuma, `set()` -yazma pointcut'larında kullanılır. İsteğe göre belirlenen @annotation ve erişim belirleyicisi dışında, alan ismi, alan tipi ve alanın yaratıldığı tip (sınıf vb.) belirtilerek gerekli noktalar işaretlenir.

[source,aspectj]
----
package com.book;
public class Library { 
    public double amount;
    public void doSomething(){ 
        System.out.println(amount=10.1);
    }
}

package com.store;
public class BookStore extends Library { 
    private statix double amount;
    public static void doSomething(){ 
        System.out.println(amount);
    }
}

package com.aspects;
public aspect LibraryAspect {
    pointcut doPointcut(): set(double amount);      <1>
    
    after() : doPointcut() {
        // advice body
    }
}

package com.aspects;
public aspect LibrarianAspect {
    pointcut doPointcut():  get(double amount);     <2>
    before() : doPointcut() {
        // advice body        
    }
 }
----
<1> Sistemde, veri tipi `double` olan ve `amount` ismindeki alanların değer atanma noktalarını belirler. `Library` sınıfının içindeki alan ataması `amount = 10.1` noktası bir alan yazma birleşim noktasıdır.

<2> Sistemde, veri tipi `double` olan ve `amount` ismindeki alanların değer okuma noktalarını belirler. `BookStore` sınıfı içindeki `println` satırındaki `amount` alanı bir alan okuma birleşim noktasıdır.

#### Throw Signature Pattern

Sistemin belli gereksinimlerine göre istisna fırlatma özelliğine sahip yapıcılara ve metodlara ayrı tavsiye yürütmeleri bağlamak gerekebilir. Bunun için AspectJ `execution()` ve `call()` pointcut yapılarının içerisini  _metod_ ve _yapıcı imza_ desenleri ile beraber biraz daha genişletmemize izin vermektedir. 

.İstisna fırlatanlara bağlanma
[source,aspectj]
----
package com.book.staff;
import com.book.info.Library;
public class Librarian extends Library {
>>>>  public Librarian() throws Exception {}
>>>>  public void throwOneException() throws RuntimeException{}
>>    public void throwOneException(String param1){}
}
package com.book.aspects;
import com.book.staff.Librarian;
public aspect ValidationAspect {

2>  after() :                                                         <1>
    execution(* Librarian.throwOneException(..) throws *Exception) || <2>
    execution(Librarian.new() throws Exception){                      <3>
    	//advice body
    }
    
3>  after():                                             <4>
    execution(* Librarian.throwOneException(..)) ||      <5>
    execution(Librarian.new()){                          <6>
	    //advice body
	}
}
----
<1> Toplam da 2 birleşim noktası yakalayan `after advice` yapısı.

<2> Erişim belirleyicine, dönüş tipine ve parametre sayısına bakılmayan `Librarian` sınıfının içindeki sonu `Exception` ile biten istisnaları fırlatmaya sahip her bir `throwOneException` metodunu yakalar.

<3> Parametre almayan ve `Exception` istisnasını fırlatma özelliğine sahip `Librarian` sınıfının yapıcı metoduna işaret etmektedir.

<4> Toplam da 3 birleşim noktasını yakalayan `after advice` yapısı.

<5> Erişim belirleyicine, dönüş tipine, parametre sayısına ve hata fırlatıp fırlatmadığına bakılmayan `Librarian` sınıfının içindeki her bir `throwOneException` metodunu yakalar. Bu bilgilere göre bir parametreye sahip diğer overloaded metod `throwOneException` da yakalanır.

<6> Parametre almayan ve istisna fırlatma özelliğine bakılmayan `Librarian` sınıfının yapıcı metoduna işaret etmektedir.

TIP: İmza desenlerini kavradıktan sonra temel pointcut yapılarını kullanmak daha kolay olacaktır.

### Temel Pointcut Çeşitleri (Kinded)

Birleşim noktalarını direkt olarak erişebileceğimiz ve bu noktalara bağlanmamızda bize yardım edecek imza desenlerinide kullanacağımız temel 11 pointcut çeşidi mevcuttur. Aşağıdaki tablo bu 11 yapıyı ve kullanılacak belirli imza desenlerinide göstermektedir. Listedeki pointcut yapıları aynı zamanda <<Join Point Yapısı>> nda anlatılan birleşim noktalarına işaret etmektedir.

.Pointcut yapıları ve açıklaması
[width="100%",options="header",cols="5,4"]
|====================
| Pointcut | Anlamı 
| *call*(MethodSignature) | method çağırma 
| *call*(ConstructorSignature) | yapıcı çağırma 
| *execution*(MethodSignature) | metod yürütme 
| *execution*(ConstructorSignature) | yapıcı yürütme 
| *get*(FieldSignature) | alan okuma erişimi 
| *set*(FieldSignature) | alan yazma erişimi 
| *handler*(TypeSignature) | istisna yönetimi 
| *initialization*(ConstructorSignature) | nesne tanımlama
| *preinitialization*(ConstructorSignature) | nesne ön tanımlama
| *adviceexecution*() | tavsiye yürütme 
|====================

IMPORTANT: Bir birleşim noktası birden fazla temel pointcut türü barındıramaz! Örnek olarak, hem `get()` hem de `set()` aynı tavsiye yapısına `&&` ile bağlanırsa, tavsiye, sistemdeki hiç bir birleşim noktasına erişemez.

### Diğer Pointcut Çeşitleri (Non-Kinded)

Temel pointcut yapıları dışında farklı pointcut türleri de AspectJ dili tarafından gelmektedir. Bu pointcut türleri, imza desenleri dışında belli kriterlere göre birleşim noktalarını seçmektedirler.  Ayrıca bu yapıların bazıları birleşim noktalarındaki bazı bilgilere (runtime types, control flow ve lexical scope gibi) ulaşmamıza yardımcı olmaktadır.

#### Lexical Scope Pointcut Yapıları

Lexical scope, kaynak kodların belli parçalarına denilmektedir. Bu parçalar süslü parantezler `{ }` arasında kalan kod parçalarını işaret etmektedir. Bu pointcut yapıların içerisinde belirtilen sınıfların (classes), ilgilerin (aspects), yapıcıların (constructor) veya metodların (methods) kod bölümlerini seçebiliyoruz. Birleşim noktalarını seçerken bu yapılar aynı zamanda belli kriterlere göre ulaşılacak alanı daraltmamıza ya da genişletmemize olanak sağlamaktadır. 

.Lexical scope tabanlı pointcut yapıları
[width="100%",options="header",cols="4,5"]
|====================
| Pointcut | Anlamı 
| *withincode*(MethodSignature) | Bir metod gövdesindeki her bir birleşim noktasını seçmek için 
| *withincode*(ConstructorSignature) | Bir yapıcı gövdesindeki her bir birleşim noktasını seçmek için 
| *within*(TypeSignature) | Sınıflar, ilgiler ve iç içe geçmiş sınıfların içerisindeki her bir birleşim noktasını seçmek için 
|====================

.Lexical scope tabanlı pointcut örnekleri
[width="100%",options="header",cols="4,4"]
|====================
| Örnek Pointcut | Açıklaması 
| *withincode*
(* com.book.Library.doSomething(..)) | `Library` sınıfı içerisindeki, belirleyicisi, dönüş tipi ve parametre sayısına bakılmaksızın, `doSomething` metodu içerisindeki *tüm* birleşim noktalarını içerir.
| *within*(com.book.Library+) | `Library` sınıfı ve ondan türeyen alt sınfların içerisindeki *tüm* birleşim noktalarını içerir.
| *!within*(* && is(InnerType)) | Sistemde sınıf ve ilgilerin içerisinde barınan dahili (inner) tiplerin (sınıf ve ilgiler) içindeki birleşim noktalarını hesaba katmaz.    
|====================

#### Execution-Object Tabanlı Pointcut Yapıları

Bu yapılar birleşim noktalarını nesnelerin tiplerine göre seçerler. `this()` ve `target()` yapılarında belirtilen tip ya da nesne belirleyicisi ile maruz kalınan yapılardaki tüm birleşim noktalarını hedef olarak alır.

.This ve Target yapıları
[width="100%",options="header",cols="3,6"]
|====================
| Pointcut | Anlamı 
| *this*(Type) |  Bir `this()` yapısının içerisinde belirlenecek bir `<Tip>` -- sınıf,alt sınıf,ilgi -- , `this instanceof <Type>` koşulunu sağladığı tüm yerlerin -alt birimler dahil- birleşim noktalarını seçer   
| *this*(ObjectIdOfType) | Bir `this()` yapısının içerisinde belirlenecek bir `<Tipin>` nesnesi, `this instanceof <Type>` koşulunu sağladığı tüm yerlerin -- alt birimler dahil -- birleşim noktalarını seçer
| *target*(Type) |  Bir `target()` yapısı `this()` ile aynı özellikleri bünyesinde barındırmaktadır ama ayrıca başka birimlerde yaratılan `<Tipin>` nesnesinden yapılan metod çağırmalarını da seçer.  
| *target*(ObjectIdOfType) | Bir `target()` yapısı `this()` ile aynı özellikleri bünyesinde barındırmaktadır ve ayrıca başka birimlerde yaratılan `<Tipin>` nesnesinden yapılan metod çağırmalarını da seçer.
|====================

IMPORTANT: `this()` ve `target()` statik yapıdaki metodlara erişemezler çünkü statik metodlar nesneye bağlı değil sınıfa bağlıdırlar.

IMPORTANT: `this(ObjectIdOfType)` ve `target(ObjectIdOfType)`, eğer ilgiler ile tipler aynı paket içindeler ise tip nesnesine ait `public`, `protected` ve `default` olarak tanımlanmış alan ve metod yapılarını tavsiyelerin içlerinde kullanılmasını, eğer ilgiler ve tipler farklı paketler içindeler ise tip nesnesine ait sadece `public` olarak tanımlanmış alan ve metod yapılarını tavsiyelerin içlerinde kullanılmasını sağlamaktadırlar. Aşağıdaki kodlar buna bir örnektir.

[source,aspectj]
----
package com.book;
>> public class Library {

    public String libraryName;
    
>>  public void doSomethingMore(Object object) {
>>       libraryName = "D&R";
    } 

   public static void doWhat() {}
}

package com.book.building;
public class StoreBook {
    public void doSomethingMore(Object object) {}
}

package com.book.staff;
>> public class Librarian extends Library{

>>  public void doSomethingMore(String str) { }
    
>>  public void doSomethingMore() { }

}

package com.book.aspects;
public aspect ObjectModule {

    pointcut doPointcut(Librarian librarian) : target(librarian); <1>
    
    after(Librarian librarian): doPointcut(librarian){
>>      System.out.println(librarian.libraryName);
>>      librarian.doSomethingMore();
    } 
    
    
    public static void main(String... args){
        Library lib = new Library();  
>>      lib.doSomethingMore(null);
        Library.doWhat();
    }
}
----
<1> Tanımlanan `target(librarian)` ile mevcut sistemdeki maruz kalınan tüm noktalar `>>` yardımıyla işaretlenmiştir. Bunu `this(librarian)` ile değiştirseydik eğer, `main()` metodunun içerisindeki ve tavsiye yapısının içerisindeki *alan okuma* ve *metod çağırmalarını* hesaba katmıyor olacaktık. Dikkat edilirse, `Library.doWhat()` satırı hem `target()` hem de `this()` ile yakalanmamaktadır.

'''

.Örnek Soru 3:
[source,aspectj]
----
package com.book;
public class Library {

  protected String libraryName;
    
  public void doSomethingMore(Object object, byte b) {
       libraryName = "D&R";
  } 

  public static void doWhat() {}
}

package com.book.aspects;
public aspect ObjectModule {

    pointcut doPointcut(Library lib) : target(lib);
    
    after(Library lib): doPointcut(lib){
      System.out.println(lib.libraryName);
      lib.doWhat();
    }
}
----
Yukarıdaki kodun hatasız çalışması için hangi seçenek(ler) yapılmalıdır?::
    - [ ] a) `libraryname` ismindeki alan `public` olmalı
    - [ ] b)  Statik metod olan `doWthat`, `Library.doWhat()` olarak yazılmalıdır
    - [ ] c)  Statik metodlar tavsiye içinde çalışmazlar.
    - [ ] d)  `libraryname` ismindeki alan `default` olmalı
    - [ ] e)  Kod hatası yoktur

#### Argument Pointcut Yapısı

Argument (yani parametre/argüman) pointcut yapısı `args(<param1,param2,...,paramN>)` ile gösterilir. Bu pointcut, metod ve yapıcı birleşim noktaları açısından, seçilen metod ve yapıcının parametre nesnelerine işaret etmektedir. Aynı şekilde, exception-handler (istisna yönetimi) birleşim noktalarında, bu yapı fırlatılan istisna nesnesine işaret etmektedir ve son olarak, alan yazma birlesim noktası için yeni değeri alır. `args()` yapısı runtime sırasında bu değerleri alır ve tavsiye içerisinde kullanılmasına olanak sağlar.

.Args pointcut örneği
[source,aspectj]
----
package com.book;
public class Library {
  public void doSomething(String param1, int param2) {}
}

package com.book.aspects;
public aspect ArgAspect {
    pointcut doPointcut(String param1) : 
            call(* com.book.Library.doSomething(String,..)) &&      <1>
            args(param1,..) &&                                      <2>
            within(ArgAspect);                                      <3>
            
    after(String param1): doPointcut(param1){
        System.out.println("Log: doSomething param1 is :"+param1);  <4>
    }
    
    public static void main(String... args){
        Library lib = new Library();  
>>      lib.doSomething("First",1);                                 <5>
    }
}
----
<1> Sadece `Library` sınıfında tanımlı olan erişim belirliyicisine ve dönüş tipine bakılmaksızın ve ilk parametresi `String` sınıfından olan her bir `doSomething` metodunun çağırılma noktalarını seçer.

<2> `doSomething` metodunun ilk parametresinin değerini alır.

<3> Birleşim noktası arama sınırını daraltarak sadece `ArgAspect` ilgisinin içini belirtir

<4> Yakalanan ilk parametre değerini tavsiye içinde asıl metodun çağırılmasından önce ekrana yazdırır.

<5> Birleşim noktası olarak tek bu satır bulunur ve eşlenilir.

#### If Conditional Pointcut Yapısı

`if(booleanExpression)` yapısı dinamik olarak çalışmaktadır. Çalışma zamanında `if`, boolean ifadesine göre birleşim noktalarının (yani tavsiye yapılarının) aktif olup olmayacağını tespit eder. `if(true)`, her koşulda seçilen birleşim noktalarının çalışacağını belli ettiği gibi `if(false)`, seçilen birleşim noktalarını çalışma zamanı içinde iptal eder ve mevcut tavsiye yapıları birleşim noktalarında çalışamazlar. 

.If pointcut örneği
[source,aspectj]
----
package com.book.aspects;
public aspect ArgAspect {

    static boolean isAvailable;

    pointcut doPointcut(String param1) : 
            call(* com.book.Library.doSomething(String,..)) &&      
            args(param1,..) &&                                      
            within(ArgAspect) &&
            if(isAvailable);                                        <1>
            
    after(String param1): doPointcut(param1){
        System.out.println("Log: doSomething param1 is :"+param1);  
    }
    
    public static void main(String... args){
        Library lib = new Library();  
        isAvailable = true;
>>      lib.doSomething("First",1);                                 <2>
        isAvailable = false;
        lib.doSomething("Second",2);                                <3>
    }
}
----
<1> statik `boolean` koluşunu mevcut diğer pointcut yapıları ile bağlıyoruz

<2> `isAvailable` alanının değeri ilk başta `true` olduğu için ilk metod çağırma noktası bir birleşim noktasıdır (`>>` ile gösterilen satır).

<3> Programın akışına göre `isAvailable` alanının değeri `false` oluyor ve 2. metod çağırma noktası çalışma zamanında inaktif oluyor ve tavsiye yapısı o noktada çalışmıyor. Kısaca o nokta, birleşim noktası olarak gözükmemektedir.

#### Control-Flow Tabanlı Pointcut Yapıları

Son pointcut yapıları olan `cflow()` ve `cflowbelow()`, kontrol akışında etki göstermektedirler. Bu yapılar kendi içlerinde başka pointcut yapıları tarafından oluşturulurlar. Diğer bir deyişle, başka bir pointcut yapısı tarafından seçilen birleşim noktalarının kontrol akışında meydana gelen diğer birleşim noktalarını seçerler. Bu yapıları kullanarak mevcut sistemdeki tüm kontrol akışına tavsiyelerde bulunabiliriz.

.Control-Flow tabanlı pointcut yapıları
[width="100%",options="header",cols="3,5"]
|====================
| Pointcut | Anlamı 
| *cflow*(`Pointcut`) | Bir pointcut ile seçilen birlesim noktaları ile *birlikte*, o birlesim noktalarının kontrol akışında meydana gelen birlesim noktalarını da otomatik olarak seçer.
| *cflowbelow*(`Pointcut`) | Bir pointcut ile seçilen birlesim noktaları *hariç* tutularak (yani kontrol akışını başlatan noktalar hariç tutularak), sadece o birlesim noktalarının kontrol akışında meydana gelen birlesim noktalarını otomatik olarak seçer.
|====================

IMPORTANT: `cflow` ve `cflowbelow` derleme zamanında belirlenmiyorlar! Dinamik olarak çalışma zamanında programın akışına göre kesinleşmektedirler.

.Cflow Örneği:
[source,aspectj]
----
package com.book.info;
import com.book.staff.Librarian;
import com.book.store.StoreBook;
public class Library {

>>  public void doSomethingLibrary() {
>>      StoreBook store = new StoreBook();
>>      store.doSomethingMore(null, 1);
>>      Librarian librarian = new Librarian();
>>      librarian.doSomethingLibrarian(null, 4);
    }
}

package com.book.staff;
import com.book.info.Library;
>> public class Librarian extends Library {

>>  public void doSomethingLibrarian(Object object, int b) {
>>      doNothing();
    } 
    
>>  public void doAnything(Object object) {
>>      System.out.println("Voila!!");
    }
    
    
>>  public void doNothing() {
>>      doAnything(null);
    }   
}

package com.book.store;
>> public class StoreBook {
   >>  public void doSomethingMore(Object param1, int param2) {
       }
}

package com.book.aspects;
import com.book.info.Library;
aspect AspectCflow {
    pointcut doPointcut() : 
                cflow(execution(* Library.doSomethingLibrary())) && <1>
                !within(AspectCflow);                               <2>

    before(): doPointcut(){ 
        System.out.println(thisJoinPoint);                          <3>
    }   
}

package test;
import com.book.info.Library;
public class Test {
        public static void main(String... args) {
            Library lib = new Library();
            lib.doSomethingLibrary();
        }
}
----
<1> `cflow` içinde metod yürütme (method-execution) birleşim noktası olarak `doSomethingLibrary` metodunu seçiyoruz

<2>  Aspect birimi içindeki tüm noktaları hariç tutuyoruz.

<3> `thisJoinPoint` özel bir değişkendir ve tavsiye yapılarının içinde her bir birlesim noktasına ait bilgileri döndürür. Tavsiye yapılarını incelerken bu değişkene de bakılacaktır. 

.Cflow Çıktısı
----
execution(void com.book.info.Library.doSomethingLibrary())                  <1>
call(com.book.store.StoreBook())
staticinitialization(com.book.store.StoreBook.<clinit>)
preinitialization(com.book.store.StoreBook())
initialization(com.book.store.StoreBook())
execution(com.book.store.StoreBook())
call(void com.book.store.StoreBook.doSomethingMore(Object, int))
execution(void com.book.store.StoreBook.doSomethingMore(Object, int))
call(com.book.staff.Librarian())
staticinitialization(com.book.staff.Librarian.<clinit>)
preinitialization(com.book.staff.Librarian())
preinitialization(com.book.info.Library())
initialization(com.book.info.Library())
execution(com.book.info.Library())
initialization(com.book.staff.Librarian())
execution(com.book.staff.Librarian())
call(void com.book.staff.Librarian.doSomethingLibrarian(Object, int))
execution(void com.book.staff.Librarian.doSomethingLibrarian(Object, int))
call(void com.book.staff.Librarian.doNothing())
execution(void com.book.staff.Librarian.doNothing())
call(void com.book.staff.Librarian.doAnything(Object))
execution(void com.book.staff.Librarian.doAnything(Object))
get(PrintStream java.lang.System.out)
call(void java.io.PrintStream.println(String))
Voila!!
----
<1> Çıktıyı dikkatle incelersek, `cflow` içinde tanımlanan pointcut yardımıyla birleşim noktalarını -bu örnekte `execution(void com.book.info.Library.doSomethingLibrary())`- belirledikten sonra kontrol akışında bulunan tüm birleşim noktalarında (pointcut ile bulunan dahil) bağlanan tavsiye yapısı çalışıyor.

<<<

.CflowBelow Örneği:
[source,aspectj]
----
package com.book.info;
import com.book.staff.Librarian;
import com.book.store.StoreBook;
public class Library {

X   public void doSomethingLibrary() {
>>      StoreBook store = new StoreBook();
>>      store.doSomethingMore(null, 1);
>>      Librarian librarian = new Librarian();
>>      librarian.doSomethingLibrarian(null, 4);
    }
}
package com.book.staff;
import com.book.info.Library;
>> public class Librarian extends Library{

>>  public void doSomethingLibrarian(Object object, int b) {
>>      doNothing();
    } 
    
>>  public void doAnything(Object object) {
>>      System.out.println("Voila!!");
    }
    
>>  public void doNothing() {
>>      doAnything(null);
    }   
}
package com.book.store;
>> public class StoreBook {
    >> public void doSomethingMore(Object param1, int param2) {
       }
   }

package com.book.aspects;
import com.book.info.Library;
aspect AspectCflow {
    pointcut doPointcut():
                cflowbelow(execution(* Library.doSomethingLibrary())) <1>
                && !within(AspectCflow);

    before(): doPointcut(){ 
        System.out.println(thisJoinPoint);
    }   
}

package test;
import com.book.info.Library;
public class Test {
        public static void main(String... args) {
            Library lib = new Library();
            lib.doSomethingLibrary();
        }
}
----
<1> `cflowbelow()` yapısı aynı birleşim noktası için kullanılıyor. `X` ile gösterilen birlesim noktası `cflowbelow` tarafından dışlanan noktadır. Diğer birleşim noktaları (`>>` ile gösterilen birleşim nokta gölgeleri), kontrol akışında bulundukları için her biri dikkate alınır.

.CflowBelow Çıktısı
----
call(com.book.store.StoreBook())                            <1>
staticinitialization(com.book.store.StoreBook.<clinit>)
preinitialization(com.book.store.StoreBook())
initialization(com.book.store.StoreBook())
execution(com.book.store.StoreBook())
call(void com.book.store.StoreBook.doSomethingMore(Object, int))
execution(void com.book.store.StoreBook.doSomethingMore(Object, int))
call(com.book.staff.Librarian())
staticinitialization(com.book.staff.Librarian.<clinit>)
preinitialization(com.book.staff.Librarian())
preinitialization(com.book.info.Library())
initialization(com.book.info.Library())
execution(com.book.info.Library())
initialization(com.book.staff.Librarian())
execution(com.book.staff.Librarian())
call(void com.book.staff.Librarian.doSomethingLibrarian(Object, int))
execution(void com.book.staff.Librarian.doSomethingLibrarian(Object, int))
call(void com.book.staff.Librarian.doNothing())
execution(void com.book.staff.Librarian.doNothing())
call(void com.book.staff.Librarian.doAnything(Object))
execution(void com.book.staff.Librarian.doAnything(Object))
get(PrintStream java.lang.System.out)
call(void java.io.PrintStream.println(String))
Voila!!
----
<1> `cflowbelow` yapısı gereği, method-execution birleşim noktası mevcut çıktının dışında kalmış ve başlangıç noktası içinde, kontrol akışındaki ilk birleşim noktası olan `StoreBook store = new StoreBook();` ile başlamış ve gene aynı düzen içinde sonlanmıştır.